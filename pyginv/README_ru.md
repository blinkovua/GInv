# PyGInv: исследование и решение полиномиальных и дифференциальных систем

**Ю. А. Блинков**  
E-mail: blinkovua@info.sgu.ru

**Аннотация:**  
Представлены вычисления в пакете PyGInv базисов Грёбнера в полиномиальных и дифференциальных системах и построении численных схем. Результаты позволяют найти размерность пространства решений. Численно найти все решения в полиномиальном случае для нульмерных идеалов. Вычислить симметрии дифференциальных уравнений без использования специальных формул. Проводить преобразования с разностными схемами, например, в случае компактных разностных схем. Пакет PyGInv представляет собой облегчённый вариант GInv, написанный на чистом Python и интегрирован с системой компьютерной алгебры SymPy.

**Ключевые слова:** компьютерная алгебра, базисы Грёбнера, полиномиальные системы, дифференциальные уравнения

## Базисы Грёбнера

Исторически, работы в направлении создания теории базисов Гребнера были ориентированы на конструктивное решение задачи принадлежности к идеалу [1-4].

Альтернативный подход методу базисов Грёбнера сформировался при исследовании дифференциальных уравнений [5-7]. Он был ориентирован на приведение системы к виду, по которому можно было определить размерность пространства решений.

Разницу между между базисами Грёбнера и его расширением инволютивным базисом лучше всего продемонстрировать на рисунке 1. На левом рисунке разном цветом показаны конуса из делимых мономов. В результате фиксирования упорядочения мономов в общем полиномиальном случае на месте пересечения конусов необходимо вычислить S-полиномы по текущему базису и добавить их в базис. По окончание этого процесса будет получен базис Грёбнера в выбранном порядке. Теперь для определения принадлежности достаточно вычислить значение полинома по текущему базису. При этом последовательность редукций не важна, поскольку все S-полиномы уже принадлежат базису. В данном случае легко посчитать полином Гильберта HP₈ = 3s + 10, который состоит из трех одномерных конусов x^s, y^s, xy^s и некоторого количества мономов, которые в эти конуса не попадают 1_ℳ, x, y, x², xy, ... В результате формула HP₈ = 3s + 10 подобрана так, что дает точное значение мономов до полной степени s ≥ 8, которые не имеют делителя среди элементов базиса.

![Рисунок 1](divfull.png)

![Рисунок 2](divjanet.png)

![Рисунок 3](divjanetfull.png)

В общем случае такой подсчет затруднительно сделать. Если бы конуса не пересекались, то вычисление полинома Гильберта можно представить разность конуса с единичного монома 1_ℳ и суммы по всем конусам образованными мономами базиса.

Инволютивное разбиение переменных переменных Janet запрещает деление по переменным, называемым немультикативными. В результате конуса на рисунке 2 не пересекаются, но и имеются незаполненные конусы. На рисунке 3 представлен базис приведенный в инволюцию за счет пополнения текущего базис продолжениями по немультикативным переменным. Инволютивный подход к построение базисов Грёбнера был развит в работах [8-10].

## PyGinv

PyGInv представляет собой "легковесную" версию GIinv [11, 12] (сокращение от Gröbner INVolutive). Написана на "чистом" Python и использует систему компьютерной алгебры SymPy (https://www.sympy.org/) для работы с параметрами. По возможности PyGInv позволяет экспорт/импорт данных в SymPy. Для построения дерева Janet опционально используется пакет Graphviz (https://graphviz.org/).

В настоящее время PyGInv позволяет строить базисы Грёбнера для полиномов, модулей, линейных дифференциальных уравнений и линейных разностных схем. Во многих случаях, как будет показано ниже, можно работать и с нелинейными дифференциальными уравнениями и разностными схемами. PyGInv содержит дополнительные функции для исследования и решения полиномиальных и дифференциальных систем.

Исходный код представленный в четырех файлах (`monomial.py`, `polynomial.py`, `janet.py`, `ginv.py`) занимает чуть меньше 2000 строк кода. Все исходные файлы и файла примеров, в том числе, и изложенных ниже находятся по адресу https://github.com/blinkovua/GInv/tree/master/pyginv.

Используя отлаженный интерфейс PyGInv планируется частично перенести его в пакет GIinv написанный на C++11 и использующий собственный менеджер памяти [13] для символьных вычислений и "длинной" арифметики.

Все вычисления произведены на процессоре Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz, с 16 G оперативной памяти в системе Debian 12.

## Полиномы и модули

Рассмотрим чисто мономиальный базис, рассмотренный на рисунках 1-3.

В строке 1 происходит импорт PyGInv в виде головного модуля `ginv.py`.

В 3 строке задается вид допустимого упорядочения. Сейчас реализованы `POTlex`, `TOPlex`, `POTdeglex` и `TOPdeglex`. В их именах `lex` означает лексикографическое, `deglex` по полной степени обратно-лексикографическое. Соответственно, `POT` -- позиция старше терма, а `TOP` -- терма старше позиции.

```python
from ginv import *

Monom.cmp = Monom.TOPdeglex
x, y = Poly.init('x, y'.split(', '))
mnm = Janet()
res = ginvBlockLow((x**7*y, x**5*y**2, \
   x**4*y**3, x**2*y**4), mnm, level=1)
mnm.saveImage('mnm.pdf')
```

Строка 4 задает переменные `x`, `y` с порядком $x \succ y$. Строка 5 определяет вид инволютивного деления, сейчас реализовано только деление Janet на основе бинарного дерева Janet~[1] представленного на рисунках 4, 5. Сохранение результата в виде дерева Janet происходит на строке 8. На строке 9-10 происходит вызов алгоритма `ginvBlockLow` реализующий блочную стратегию описанную в работе~[2], которая работает только в упорядочении `TOPdeglex`. Алгоритм `ginvMin` реализующий минимальную стратегию работает при все видах упорядочения.

![Рисунок](mnm.png)

На рисунках 4, 5 показаны разные уровни вывода информации. На рисунке отображена только структура дерева и жирным обозначены мономы принадлежащие базису редуцированному базиса Грёбнера, а простым шрифтом мономы которые принадлежат дополнительно минимальному инволютивному базису~[3].

Ниже на строках 1--17 продемонстрировано вычисление базиса Грёбнера для стандартного примера циклических корней. В данном случае полученный идеал является нульмерным $HP_{6}=4s+6$.

```python
Monom.cmp = Monom.TOPdeglex
x1, x2, x3, x4 = \
  Poly.init('x1, x2, x3, x4'.split(', '))
cyclic4 = Janet()
res = ginvBlockLow((
x1+x2+x3+x4,\
x1*x2+x2*x3+x3*x4+x4*x1,\
x1*x2*x3+x2*x3*x4+x3*x4*x1+x4*x1*x2,\
x1*x2*x3*x4-1), \
cyclic4, level=1)
print(f"    crit1: {res[1]}")
print(f"    crit2: {res[2]}")
print(f"     time: {res[0]:.2f} sec")
print(f"    count: {cyclic4.count()}")
print(f"reduction: {cyclic4.reduction()}")
print(f"       HP: {cyclic4.HP()}")
cyclic4.saveImage('cyclic4.pdf', level=3)
```

В строках 11--17 показан вывод различной информации связанной с вычислением. Их результат представлен ниже в строках 18--23.

```python
    crit1: 6
    crit2: 0
     time: 0.02 sec
    count: 7
reduction: 54
       HP: 4s + 6
```

На рисунке 5 дополнительно по сравнению ниже монома выведены его немультакативные переменные и построенные по ним продолжения. В самом низу записан "предок", по нему работают критерии Бухбергера~[4] и некоторые виды инволютивных делений~[5], пока нереализованные в PyGInv.

![Рисунок](cyclic4.png)

На строках 24--34 произведен вывод базиса Грёбнера. Используемая обертка в виде класса `Wrap` содержит много технической информации для эффективной организации вычислений.

```python
for w in cyclic4.GB():
    print(w.poly)
x3**2*x4**4 + x2*x3 + x2*x4*-1 + x3*x4 + \
  x4**2*-2
x3**3*x4**2*-1 + x3**2*x4**3*-1 + x3 + x4
x2*x4**4*-1 + x4**5*-1 + x2 + x4
x2*x3*x4**2 + x3**2*x4**2 + x2*x4**3*-1 + \
  x3*x4**3 + x4**4*-1 + -1
x2*x3**2*-1 + x3**2*x4*-1 + x2*x4**2 + x4**3
x2**2*-1 + x2*x4*-2 + x4**2*-1
x1 + x2 + x3 + x4
```

На строках 1--12 показана организация вычислений с помощью модуля сизигий для четвертых циклических корней. Для этого вводятся зависимые переменные на строке 2 с порядком переменных $f \succ p_1 \succ  p_2 \succ  p_3 \succ  p_4$. В модулях они играют туже роль, что функции в дифференциальных уравнениях и разностных схемах. Внутри это организованно в виде положительного числа, которое определяет позицию. Естественно они должны входить в выражение только линейно. В данном примере у нас по числу зависимых переменных 6 различных деревьев Janet. Поэтому на строке 6 используется обертка в виде класса `Forest`. Предполагается, что она будет работать на других видах инволютивных делений.

```python
var = 'x1, x2, x3, x4'.split(', ')
fun = 'f, p1, p2, p3, p4'.split(', ')
var, fun = Poly.init(var, fun)
x1, x2, x3, x4 = var
f, p1, p2, p3, p4 = fun
cyclic4 = Forest(Janet)
res = ginvMin((
f*(x1+x2+x3+x4)-p1,\
f*(x1*x2+x2*x3+x3*x4+x4*x1)-p2,\
f*(x1*x2*x3+x2*x3*x4+x3*x4*x1+x4*x1*x2)-p3,\
f*(x1*x2*x3*x4-1)-p4), \
cyclic4, level=1)
```

Для построения сизигий необходимо только выражения не содержащие зависимую переменную `f` поэтому цикл на строке 14 начинается с позиции 1. Для данной системы не потребовалось исключающего упорядочения. На строках 15--19 показан перевод вычислений в представление SymPy записанной в векторном виде.

```python
syzygy = []
for i in range(1, 5):
  for w in cyclic4[i].GB():
    syzygy.append(tuple(sympy.Add(\
*tuple(eval(f"{m.lcm(fun[k].lm())}*{c}") \
for m, c in w.poly if m.position() == k),\
   evaluate=False) for k in range(1, 5)))
syzygy   
```

$[ ( x_{3}^{2} x_{4}^{4} - x_{4}^{2},   x_{2} x_{3}^{2} x_{4}^{2} - x_{2} x_{4}^{4} - x_{3}^{2} x_{4}^{3} - x_{3} x_{4}^{4} + x_{3} + x_{4}, \\  - x_{2} x_{3}^{2} x_{4} + x_{2} x_{4}^{3} + x_{4}^{4} - 1,   x_{2} x_{3}^{2} - x_{2} x_{4}^{2} + x_{3}^{2} x_{4} - x_{4}^{3}),\\  ( x_{2} x_{3}^{2} + x_{3}^{2} x_{4},   - x_{2} x_{3} - x_{2} x_{4} - x_{3}^{2} - x_{3} x_{4}, \  x_{2} + x_{4},   0), \\  ( - x_{2} - x_{4},   - x_{2}^{2} x_{4}^{2} + 1,  x_{2}^{2} x_{4} + x_{2} x_{4}^{2},  - x_{2}^{2} - 2 x_{2} x_{4} - x_{4}^{2})]$

На строках 21--28 выполнена проверка правильности построения трех полученных сизигий.

```python
P = (x1+x2+x3+x4,\
x1*x2+x2*x3+x3*x4+x4*x1,\
x1*x2*x3+x2*x3*x4+x3*x4*x1+x4*x1*x2,\
x1*x2*x3*x4-1)
for syz in syzygy:
  print(sum(s*p for s, p \
    in zip(syz, P)).expand(), end=" ")
0 0 0
```

```
