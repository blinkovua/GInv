# PyGInv: исследование и решение полиномиальных и дифференциальных систем

**Ю. А. Блинков**  
E-mail: blinkovua@info.sgu.ru

**Аннотация:**  
Представлены вычисления в пакете PyGInv базисов Грёбнера в полиномиальных и дифференциальных системах и построении численных схем. Результаты позволяют найти размерность пространства решений. Численно найти все решения в полиномиальном случае для нульмерных идеалов. Вычислить симметрии дифференциальных уравнений без использования специальных формул. Проводить преобразования с разностными схемами, например, в случае компактных разностных схем. Пакет PyGInv представляет собой облегчённый вариант GInv, написанный на чистом Python и интегрирован с системой компьютерной алгебры SymPy.

**Ключевые слова:** компьютерная алгебра, базисы Грёбнера, полиномиальные системы, дифференциальные уравнения

## Базисы Грёбнера

Исторически, работы в направлении создания теории базисов Гребнера были ориентированы на конструктивное решение задачи принадлежности к идеалу [1-4].

Альтернативный подход методу базисов Грёбнера сформировался при исследовании дифференциальных уравнений [5-7]. Он был ориентирован на приведение системы к виду, по которому можно было определить размерность пространства решений.

Разницу между между базисами Грёбнера и его расширением инволютивным базисом лучше всего продемонстрировать на рисунке 1. На левом рисунке разном цветом показаны конуса из делимых мономов. В результате фиксирования упорядочения мономов в общем полиномиальном случае на месте пересечения конусов необходимо вычислить S-полиномы по текущему базису и добавить их в базис. По окончание этого процесса будет получен базис Грёбнера в выбранном порядке. Теперь для определения принадлежности достаточно вычислить значение полинома по текущему базису. При этом последовательность редукций не важна, поскольку все S-полиномы уже принадлежат базису. В данном случае легко посчитать полином Гильберта HP₈ = 3s + 10, который состоит из трех одномерных конусов x^s, y^s, xy^s и некоторого количества мономов, которые в эти конуса не попадают 1_ℳ, x, y, x², xy, ... В результате формула HP₈ = 3s + 10 подобрана так, что дает точное значение мономов до полной степени s ≥ 8, которые не имеют делителя среди элементов базиса.

![Рисунок 1](divfull.png)

![Рисунок 2](divjanet.png)

![Рисунок 3](divjanetfull.png)

В общем случае такой подсчет затруднительно сделать. Если бы конуса не пересекались, то вычисление полинома Гильберта можно представить разность конуса с единичного монома 1_ℳ и суммы по всем конусам образованными мономами базиса.

Инволютивное разбиение переменных переменных Janet запрещает деление по переменным, называемым немультикативными. В результате конуса на рисунке 2 не пересекаются, но и имеются незаполненные конусы. На рисунке 3 представлен базис приведенный в инволюцию за счет пополнения текущего базис продолжениями по немультикативным переменным. Инволютивный подход к построение базисов Грёбнера был развит в работах [8-10].

## PyGinv

PyGInv представляет собой "легковесную" версию GIinv [11, 12] (сокращение от Gröbner INVolutive). Написана на "чистом" Python и использует систему компьютерной алгебры SymPy (https://www.sympy.org/) для работы с параметрами. По возможности PyGInv позволяет экспорт/импорт данных в SymPy. Для построения дерева Janet опционально используется пакет Graphviz (https://graphviz.org/).

В настоящее время PyGInv позволяет строить базисы Грёбнера для полиномов, модулей, линейных дифференциальных уравнений и линейных разностных схем. Во многих случаях, как будет показано ниже, можно работать и с нелинейными дифференциальными уравнениями и разностными схемами. PyGInv содержит дополнительные функции для исследования и решения полиномиальных и дифференциальных систем.

Исходный код представленный в четырех файлах (`monomial.py`, `polynomial.py`, `janet.py`, `ginv.py`) занимает чуть меньше 2000 строк кода. Все исходные файлы и файла примеров, в том числе, и изложенных ниже находятся по адресу https://github.com/blinkovua/GInv/tree/master/pyginv.

Используя отлаженный интерфейс PyGInv планируется частично перенести его в пакет GIinv написанный на C++11 и использующий собственный менеджер памяти [13] для символьных вычислений и "длинной" арифметики.

Все вычисления произведены на процессоре Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz, с 16 G оперативной памяти в системе Debian 12.

## Полиномы и модули

Рассмотрим чисто мономиальный базис, рассмотренный на рисунках 1-3.

В строке 1 происходит импорт PyGInv в виде головного модуля `ginv.py`.

В 3 строке задается вид допустимого упорядочения. Сейчас реализованы `POTlex`, `TOPlex`, `POTdeglex` и `TOPdeglex`. В их именах `lex` означает лексикографическое, `deglex` по полной степени обратно-лексикографическое. Соответственно, `POT` -- позиция старше терма, а `TOP` -- терма старше позиции.

```python
from ginv import *

Monom.cmp = Monom.TOPdeglex
x, y = Poly.init('x, y'.split(', '))
mnm = Janet()
res = ginvBlockLow((x**7*y, x**5*y**2, \
   x**4*y**3, x**2*y**4), mnm, level=1)
mnm.saveImage('mnm.pdf')
```

Строка 4 задает переменные `x`, `y` с порядком $x \succ y$. Строка 5 определяет вид инволютивного деления, сейчас реализовано только деление Janet на основе бинарного дерева Janet~[1] представленного на рисунках 4, 5. Сохранение результата в виде дерева Janet происходит на строке 8. На строке 9-10 происходит вызов алгоритма `ginvBlockLow` реализующий блочную стратегию описанную в работе~[2], которая работает только в упорядочении `TOPdeglex`. Алгоритм `ginvMin` реализующий минимальную стратегию работает при все видах упорядочения.

![Рисунок](mnm.png)

На рисунках 4, 5 показаны разные уровни вывода информации. На рисунке отображена только структура дерева и жирным обозначены мономы принадлежащие базису редуцированному базиса Грёбнера, а простым шрифтом мономы которые принадлежат дополнительно минимальному инволютивному базису~[3].

Ниже на строках 1--17 продемонстрировано вычисление базиса Грёбнера для стандартного примера циклических корней. В данном случае полученный идеал является нульмерным $HP_{6}=4s+6$.

```python
Monom.cmp = Monom.TOPdeglex
x1, x2, x3, x4 = \
  Poly.init('x1, x2, x3, x4'.split(', '))
cyclic4 = Janet()
res = ginvBlockLow((
x1+x2+x3+x4,\
x1*x2+x2*x3+x3*x4+x4*x1,\
x1*x2*x3+x2*x3*x4+x3*x4*x1+x4*x1*x2,\
x1*x2*x3*x4-1), \
cyclic4, level=1)
print(f"    crit1: {res[1]}")
print(f"    crit2: {res[2]}")
print(f"     time: {res[0]:.2f} sec")
print(f"    count: {cyclic4.count()}")
print(f"reduction: {cyclic4.reduction()}")
print(f"       HP: {cyclic4.HP()}")
cyclic4.saveImage('cyclic4.pdf', level=3)
```

В строках 11--17 показан вывод различной информации связанной с вычислением. Их результат представлен ниже в строках 18--23.

```python
    crit1: 6
    crit2: 0
     time: 0.02 sec
    count: 7
reduction: 54
       HP: 4s + 6
```

На рисунке 5 дополнительно по сравнению ниже монома выведены его немультакативные переменные и построенные по ним продолжения. В самом низу записан "предок", по нему работают критерии Бухбергера~[4] и некоторые виды инволютивных делений~[5], пока нереализованные в PyGInv.

![Рисунок](cyclic4.png)

На строках 24--34 произведен вывод базиса Грёбнера. Используемая обертка в виде класса `Wrap` содержит много технической информации для эффективной организации вычислений.

```python
for w in cyclic4.GB():
    print(w.poly)
x3**2*x4**4 + x2*x3 + x2*x4*-1 + x3*x4 + \
  x4**2*-2
x3**3*x4**2*-1 + x3**2*x4**3*-1 + x3 + x4
x2*x4**4*-1 + x4**5*-1 + x2 + x4
x2*x3*x4**2 + x3**2*x4**2 + x2*x4**3*-1 + \
  x3*x4**3 + x4**4*-1 + -1
x2*x3**2*-1 + x3**2*x4*-1 + x2*x4**2 + x4**3
x2**2*-1 + x2*x4*-2 + x4**2*-1
x1 + x2 + x3 + x4
```

На строках 1--12 показана организация вычислений с помощью модуля сизигий для четвертых циклических корней. Для этого вводятся зависимые переменные на строке 2 с порядком переменных $f \succ p_1 \succ  p_2 \succ  p_3 \succ  p_4$. В модулях они играют туже роль, что функции в дифференциальных уравнениях и разностных схемах. Внутри это организованно в виде положительного числа, которое определяет позицию. Естественно они должны входить в выражение только линейно. В данном примере у нас по числу зависимых переменных 6 различных деревьев Janet. Поэтому на строке 6 используется обертка в виде класса `Forest`. Предполагается, что она будет работать на других видах инволютивных делений.

```python
var = 'x1, x2, x3, x4'.split(', ')
fun = 'f, p1, p2, p3, p4'.split(', ')
var, fun = Poly.init(var, fun)
x1, x2, x3, x4 = var
f, p1, p2, p3, p4 = fun
cyclic4 = Forest(Janet)
res = ginvMin((
f*(x1+x2+x3+x4)-p1,\
f*(x1*x2+x2*x3+x3*x4+x4*x1)-p2,\
f*(x1*x2*x3+x2*x3*x4+x3*x4*x1+x4*x1*x2)-p3,\
f*(x1*x2*x3*x4-1)-p4), \
cyclic4, level=1)
```

Для построения сизигий необходимо только выражения не содержащие зависимую переменную `f` поэтому цикл на строке 14 начинается с позиции 1. Для данной системы не потребовалось исключающего упорядочения. На строках 15--19 показан перевод вычислений в представление SymPy записанной в векторном виде.

```python
syzygy = []
for i in range(1, 5):
  for w in cyclic4[i].GB():
    syzygy.append(tuple(sympy.Add(\
*tuple(eval(f"{m.lcm(fun[k].lm())}*{c}") \
for m, c in w.poly if m.position() == k),\
   evaluate=False) for k in range(1, 5)))
syzygy   
```

$[ ( x_{3}^{2} x_{4}^{4} - x_{4}^{2},   x_{2} x_{3}^{2} x_{4}^{2} - x_{2} x_{4}^{4} - x_{3}^{2} x_{4}^{3} - x_{3} x_{4}^{4} + x_{3} + x_{4}, \\  - x_{2} x_{3}^{2} x_{4} + x_{2} x_{4}^{3} + x_{4}^{4} - 1,   x_{2} x_{3}^{2} - x_{2} x_{4}^{2} + x_{3}^{2} x_{4} - x_{4}^{3}),\\  ( x_{2} x_{3}^{2} + x_{3}^{2} x_{4},   - x_{2} x_{3} - x_{2} x_{4} - x_{3}^{2} - x_{3} x_{4}, \  x_{2} + x_{4},   0), \\  ( - x_{2} - x_{4},   - x_{2}^{2} x_{4}^{2} + 1,  x_{2}^{2} x_{4} + x_{2} x_{4}^{2},  - x_{2}^{2} - 2 x_{2} x_{4} - x_{4}^{2})]$

На строках 21--28 выполнена проверка правильности построения трех полученных сизигий.

```python
P = (x1+x2+x3+x4,\
x1*x2+x2*x3+x3*x4+x4*x1,\
x1*x2*x3+x2*x3*x4+x3*x4*x1+x4*x1*x2,\
x1*x2*x3*x4-1)
for syz in syzygy:
  print(sum(s*p for s, p \
    in zip(syz, P)).expand(), end=" ")
0 0 0
```

## Нахождение корней

В случае нульмерных идеалов возможно эффективное нахождение всех корней системы полиномов с учетом кратности. Рассмотрим простой пример

`{x^3 - y^2 + z - 1, y^3 - z^2 + x - 1, z^3 - x^2 + y - 1}`

с порядком переменных $x \succ y \succ z$, который в упорядочении `deglex` согласно первому критерию Бухбергера [1] является базисом Грёбнера. Минимальный инволютивный базис Janet содержит уже 13 элементов представленных только лидирующем (старшими) мономами

`{z^3, y z^3, y^2 z^3, y^3, x z^3, x y z^3, x y^2 z^3, x y^3, x^2 z^3, x^2 y z^3, x^2 y^2 z^3, x^2 y^3, x^3}`.

Применяя статическую функцию `gradus` класса `Monom` на строке 3 можно перебором по полной степени найти все мономы, которые не имеею делителя среди лидирующих мономов системы.

```python
rows, i = {}, 0
for d in range(8):
  for m in Monom.gradus(d):
    if not test.find(m):
      print(f"{m!r}", end=", ")
      rows[m] = i
      i += 1
```

На строке 5 организован вывод таких мономов во внутреннем представлении в виде списка степеней переменных. Их количество в точности равно значению полинома Гильберта $HP_{7}= 27$.

```
[0 0 0], 
[1 0 0], [0 1 0], [0 0 1], 
[2 0 0], [1 1 0], ... , [0 0 2], 
[2 1 0], [2 0 1], ... , [0 2 1], [0 1 2], 
[2 2 0], [2 1 1], ... , [0 2 2], 
[2 2 1], [2 1 2], [1 2 2], 
[2 2 2],
```

В результате после проведения всех редукций по базису Грёбнера (строка 17 вызов функции `NF`) для мономов от переменной $x$ до степени 26 включительно у нас могут возникнуть только мономы представленные на строках 8-14. Это дает возможность сопоставить каждой строке матрицы $x^d$. Аналогично можно для построения столбца `b` на строках 19-21 сопоставить моном $x^27$.

```python
A=[[0 for k in range(27)] for i in range(27)]
for d in range(27):
  for m, c in (x**d).NF(test):
    A[rows[m]][d] = c
b = [0 for i in range(27)]
for m, c in (x**27).NF(test):
  b[rows[m]] = c

A, b = sympy.Matrix(A), sympy.Matrix(b)
s = sympy.linsolve((A, b)).args[0]
p = x**27-sum(x**d*s[d] for d in range(27))
```

Решая средствами SymPy полученную систему в матричном виде найдем вид полинома принадлежащему базису рассматриваемого идеала только от одной переменной 

$x^{27} - 9 x^{24} + 29 x^{21} + 6 x^{19} - 53 x^{18} + 22 x^{17} - 63 x^{16} + 96 x^{15} - 149 x^{14} + 242 x^{13} - 261 x^{12} + 484 x^{11} - 545 x^{10} + 740 x^{9} - 908 x^{8} + 972 x^{7} - 1220 x^{6} + 1047 x^{5} - 1045 x^{4} + 943 x^{3} - 535 x^{2} + 422 x - 216$

Корни этого полинома можно найти используя функцию `nroots` системы компьютерной алгебры SymPy.

Более эффективное вычисления можно организовать используя матричное представления переменных для решения численно задачи на собственные значения. На строках 26--32 используя соотношение, что умножение мономов на переменную из строк 8--14 редуцируются относительно базиса Грёбнера снова к этому набору мономов построим матрицу для этой переменной.

```python
dct = [{}, {}, {}]
for k, v in rows.items():
  for i in range(3):
    for m, c in Poly(Monom(i)*k).NF(test):
      if c:
        dct[i][rows[m], v] = c
X, Y, Z = (SparseMatrix(27, 27, dct[i]) for i in range(3))
X*Y == Y*X and X*Z == Z*X and Z*Y == Y*Z
True
```

Матрицы имеют много нулевых элементов и не смотря на то, что не симметричны коммутируют друг с другом (строки 34-35).

Применяя библиотеку SciPy (https://scipy.org/) на строках 36--43 легко организовать вычисления собственных значений, которые в точности будут соответствовать корням исходной системы [2].

```python
import numpy as np
from scipy import linalg

A = np.empty((27, 27), dtype=np.float64)
for j in range(27):
  for k in range(27):
    A[j][k] = X[j, k]
print(linalg.eigvals(A))
```

Расчет 7-ых циклических корней в PyGInv занимает время 1225 сек. Данная система полиномов имеет 924 корня с учетом кратности. Расчет матричного представления занимает 366 сек. Заполняемость матриц выглядит следующим образом [69694, 68288, 66858, 65585, 62887, 51490, 18216], что составляет в процентах [8%, 8%, 8%, 8%, 7%, 6%, 2%]. Расчет собственных значений занимает всего 19 сек.


## Раскраска графов

Используя трюк Рабиновича [1] для представления неравенств за счет введения дополнительных переменных можно с помощью базисов Грёбнера решать задачу раскраски графов *n*-красками. Например в случае трех красок цвета для соседних вершины можно определить следующими полиномами

```python
Monom.cmp = Monom.POTlex
k, y, x = Poly.init('k, y, x'.split(', '))
test = Janet()
res = ginvMin((
x*(x+1)*(x-1),
y*(y+1)*(y-1),
(x - y)*k - 1,\
), test, level=1)
```

В последнем полиноме (строка 7) дополнительная переменная *k* не может обращаться в ноль и значит краски *x* и *y* различны. Базис Грёбнера после исключения полинома с *k* имеет следующий вид 
`x³ - x`, `y² + yx + x² - 1`, 
`2k - 3yx² + 2y - 2x`, где второй искомый полином разделяющий значения *x* и *y*.

С помощью этих соотношений можно описать все соседние вершины и построив базис Грёбнера найти все варианты раскраски данного графа.

Аналогично, например, для пяти красок можно определить следующую систему
`x(x+1)(x-1)(x+2)(x-2)`, `y(y+1)(y-1)(y+2)(y-2)`, `(x - y)k - 1` и легко
получить вид разделяющего полинома
`y⁴ + y³x + y²x² - 5y² + yx³ - 5yx + x⁴ -5x² + 4`.

Зададим граф показанный на рисунке 6 на строках 10--19. Здесь первый элемент вершина, а затем ее связи с другими вершинами.

```python
graph = (
(1, 2, 5, 8, 10),\
(2, 3, 6, 9),\
(3, 4, 7, 10),\
(4, 5, 8, 11),\
(5, 6, 12),\
(6, 7, 11),\
(7, 8, 12),\
(8, 9),\
(9, 10, 12),\
(10, 11))
```

В Python очень удобно работать со строками в результате код ниже генерирует
все требуемые полиномы для раскраски тремя красками графа на рисунке 6.

```python
var = [f"x{vs}" for vs in range(1, 13)]
eqs = [f"{v}**3 + {v}*-1" for v in var]
for vs in graph:
  w = vs[0]
  for v in vs[1:]:
    eqs.append(f"""x{w}**2*-1 + x{w}*x{v}*-1
      + x{v}**2*-1 + 1""")
```

Построение базиса Грёбнера в PyGinv заняло примерно 8 сек. 
Полином Гильберта дает 6 различных решений. Выберем в качестве корня `x₁₂ - 1`.
Построение занимает практически нулевое время, но остается выбор из двух решений.
Задавая `x₁₀ + 1` строится в точности одно решение показанное на рисунке 6. 

<center>
![Рисунок 6](color.png)
Рисунок 6
</center>
